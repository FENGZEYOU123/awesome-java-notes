> **复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本就掌握了一半。**

### 一、为什么需要复杂度分析

分析算法执行的时间和占用的内存大小，主要有两种方法：

**1. 事后统计法**

> 定义：将代码跑一遍，通过统计、监控得到算法执行的时间和占用的内存大小。

> **局限性**

- 1）测试结果非常依赖测试环境。测试环境中硬件的不同会对测试结果有很大的影响。
- 2）测试结果受数据规模的影响很大。


**2. 分析时间复杂度、空间复杂度法**

> 大 O 复杂度表示法

所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。

```java
T(n) = O(f(n))
```

- T(n) 表示代码的执行时间
- n 表示数据规模的大小
- f(n) 表示每行代码执行的次数的总和

---

**大 O 时间复杂度表示法**

- 也叫渐进时间复杂度，简称时间复杂度
- 表示代码执行时间随数据规模增长变化的趋势

> 时间复杂度分析

<u>1. 只关注循环执行次数最多的一段代码</u>
- 通常会忽视公式中的常量、低阶、系数，秩序记录一个最大阶的量级就行
- 分析一个算法、一段代码的时间复杂度时，只需关注执行次数最多的一段代码即可

<u>2. 加法法则：总的时间复杂度等于量级最大的那段代码的复杂度</u>

> 如果 T1(n)=O(f(n)), T2(n)=O(g(n))，那么T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))

<u>3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</u>

> 如果 T1(n)=O(f(n)), T2(n)=O(g(n))，那么 T1(n)*T2(n)=O(f(n)) * O(g(n))=O(f(n)*g(n))
> 也就是说，假设 <img src="http://latex.codecogs.com/gif.latex?T 1(n)=O(n), \quad T 2(n)=O\left(n^{2}\right)" /> ，则有 <img src="http://latex.codecogs.com/gif.latex?\mathrm{T} 1(\mathrm{n}) * \mathrm{T} 2(\mathrm{n})=\mathrm{O}\left(\mathrm{n}^{3}\right)" />


**示例：**

```java
int cal(int n) {
    int sum = 0;
    int i = 1;
    for (; i <= n; ++i) {
              sum += i;
    }
    return sum;
}
```

分析：第 2、3 行代码都是常量级的执行时间，与 n 的大小无关。执行次数最多的是第 4、5 行代码，所以这块代码总的时间复杂度为：O(n)


* * *


**大 O 空间复杂度表示法**、

- 也叫渐进空间复杂度，简称空间复杂度
- 表示算法的存储空间与数据规模之间的增长关系

> 示例：

```java
void print(int n) {
    int i = 0;
    int[] a = new int[n];
    for (i; i < n; ++i) {
        a[i] = i * i;
    }
    
    for (i = n - 1; i >= 0; --i) {
        System.out.println(a[i]);
    }
}
```

分析：在代码的第二行为变量 i 申请了一个存储空间，但是它是常量阶的，跟数据规模 n 没有关系，可以忽略。在代码的第 3 行申请了一个大小为 n 的存储空间存储 int 类型的数组。其与代码都没有占用更多存储空间，所以空间复杂度为：O(n)。

---
**几种常见的时间复杂度实例分析**

![f3a4fae3ac7d6685e1f1353c114a81dc.png](en-resource://database/15622:1)

- 量级分为多项式量级和非多项式量级。其中，非多项式量级只有两个：

    ```java
      <img src="http://latex.codecogs.com/gif.latex?O\left(2^{n}\right)"> 
    ```
    
- 常见复杂度从低阶到高阶：
**O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )**



---
### 二、最好、最好、平均、均摊时间复杂度

##### 1、最好时间复杂度
- 在最理想的情况下，执行这段代码的时间复杂度

##### 2、最坏时间复杂度
- 在最糟糕的情况下，执行这段代码的时间复杂度

##### 3、平均时间复杂度
- **普通含义**：把每种情况下，查找需要遍历的元素个数累加起来，然后再处以总的情况种数，就可以得到需要遍历的元素个数的平均值
- **正确求法**：用代码在所有情况下的加权平均值来表示

##### 4、均摊时间复杂度

- 在代码执行的所有复杂度情况中，大部分情况下时间复杂度都很低，只有极个别情况下的时间复杂度比较高，而且发生具有**前后连贯的时序关系**时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于**低级别复杂度**。

##### 5、如何分析平均、均摊时间复杂度？

>**1、平均时间复杂度**

代码在不同情况下出现数量级差别，则用代码所有可能情况下执行次数的加权平均值来表示。

>**2、均摊时间复杂度**

满足以下两个条件时使用：

- 1）代码在绝大多数情况下都是低级别复杂度，只有极少数情况下是高级别复杂度；
- 2）低级别和高级别复杂度的出现具有前后连贯的时序规律。

均摊结果一般都等于低级别的复杂度。
