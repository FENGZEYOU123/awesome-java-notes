#### 数组是什么？

- **定义：** 数组是一种线性表数据结构。它用一组连续的内存空间来存储一组具有相同类型的数据。


#### 如何实现随机访问？

>**1、线性表**

线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。

线性表结构的数据结构有：

![](https://github.com/bigrotor187/awesome-java-notes/blob/master/imgs/%E7%BA%BF%E6%80%A7%E8%A1%A8.png)


非线性表结构的数据结构有二叉树、堆、图等：

![](https://github.com/bigrotor187/awesome-java-notes/blob/master/imgs/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8.png)


>**2、连续的内存空间和相同类型的数据。**


**随机访问**

> 一维数组内存寻址：

`a[i]_address = base_address + i * data_type_size`

> 二维数组内存寻址：

对于 m * n 的数组，a [ i ][ j ] (i < m,j < n)的地址为：

- 按行优先：

`address = base_address + ( i * n + j ) * data_type_size`

- 按列优先：

`address = base_address + ( j * m + i
) * data_type_size`

【说明】data_type_size 表示的是数组中每个元素的大小，比如 int 型的每个元素大小为 4 个字节。

> **数组&链表**

- 链表适合插入和删除，不需要移动数据，时间复杂度为 O(1)
- 数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)


#### 低效的插入、删除操作

> 插入

- 最好时间复杂度：O(1)
- 最坏时间复杂度：O(n)
- 平均时间复杂度：(1+2+...+n)/n=O(n)

> 删除

- 最好时间复杂度：O(1)
- 最坏时间复杂度：O(n)
- 平均时间复杂度：(1+2+...+n)/n=O(n)

**优化**：某些特殊场景下，为了避免每删除一次，移动一次元素，可以先记录数据已经被删除，当数组没有更多空间存储数据时，再触发执行一次真正的删除操作。

![](https://github.com/bigrotor187/awesome-java-notes/blob/master/imgs/%E6%95%B0%E7%BB%84%E7%A7%BB%E5%8A%A8%E5%85%83%E7%B4%A0%E4%BC%98%E5%8C%96.png)

#### 警惕数组的越界问题


#### 容器能否完全替代数组？

> **ArrayList**

- 最大优势是可以将很多数组的操作细节封装起来，比如插入、删除数组的数据时需要搬移其他数据；
- ArrayList 的另一个优势是**支持动态扩容**；
- 扩容操作涉及内存申请和数据搬移，比较耗时，如果能事先确定需要存储的数据大小，最好再创建Array List时事先指定数据大小。

```Java
ArrayList<User> users = new ArrayList(10000);
for (int i = 0; i < 10000; ++i) {
  users.add(xxx);
}
```

> **ArrayList（容器）与数组如何选择？**

- 对于业务开发，直接使用容器即可，省时省力，即使可能会影响一丢丢性能，但对于整体性能的影响可以忽略不计；
- 底层开发，比如开发网络框架，性能的优化需要做到极致，此时数组优于容器，成为首选。

![](https://github.com/bigrotor187/awesome-java-notes/blob/master/imgs/ArrayList%E4%B8%8EArray%E9%80%89%E6%8B%A9.png)


#### 为什么很多编程语言中数组都从0开始编号？

> **原因一、性能优化角度**

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。如果用 a 来表示数组的首地址，那么 a[0] 就表示偏移为 0 的位置，也就是首地址。a[k] 则表示偏移 k 个
type_size 的位置，所以计算 a[k] 的**内存地址**可用如下公式：

`
a[k]_address = base_address + k * type_size 
`<br>

但是，如果数组从 1 开始计数，那么计算 a[k] 的内存地址时公式则会变为：

`a[k]_address = base_address + (k-1)*type_size` <br>

显而易见的是，从 1 开始编号，每次随机访问元素会多一次减法操作，对于 CPU 而言，就是多了一次减法指令。

数组作为非常基础的数据结构，通过下标随机访问元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以，为了减少一次减法操作，数组选择了从 0 开始编号，
而不是从 1 开始编号。


> **原因二、历史原因**

高级编程语言的老祖宗 C 语言在设计时用 0 开始计数数组下标，于是之后的 Java、JavaScript 等也都纷纷效仿。或者说，为了降低 C 语言程序员学习 Java 等语言的成本，
因此继续沿用了从 0 开始计数的习惯。

但是，并不是所有语言都沿用了 C 语言的习惯。比如 Matlab，Python 等。甚至于 Python 还支持负数下标。

---

> 说明：文中图片来源于王争老师的《数据结构与算法之美》专栏。
