## 前言

**写链表代码是最考验逻辑思维能力的**。因为，链表代码到处都是指针的操作、边界条件的处理，稍有不慎就容易产生 Bug。链表代码写得好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密。所以，这也是很多面试官喜欢让人手写链表代码的原因。所以，学习了链表一定要多加练习，才能看到更好的效果。

切忌：**思想上的巨人，行动上的矮子。**

## 思考题

> - **如何实现LRU缓存淘汰算法？**

## 什么是链表？

- 和数组一样，链表也是一种线性存储结构；
- 从底层的存储结构来看，链表并不需要一块连续的内存空间，它通过 `指针`  将一组零散的内存块串联在一起，已达到存储数据的目的；
- 链表中的每一个内存块被称为 `结点Node`。每个链表结点除了存储数据之外，还需记录链上的下一个结点的地址，即后 `继指针next`。


## 为什么要使用链表？

- 插入、删除数据效率很高，只需 O(1) 时间复杂度（只需更改链表结点指针的指向即可），随机访问效率低，需要 O(n) 时间复杂度（需要从头到尾遍历链表）；
- 和数组相比，内存空间消耗更大，因为每个链表结点除了存储数据外，还需要一个额外空间存储后继指针。


## 常用链表结构：单链表、循环链表、双向链表

### 单链表

![](https://github.com/bigrotor187/awesome-java-notes/blob/master/imgs/%E5%8D%95%E9%93%BE%E8%A1%A8.jpg)

- 单链表的每个结点只有一个指针，即 `后继指针next`；
- 单链表有两个特殊的结点：头结点和尾结点。其中，头结点表示链表的第一个结点，用来记录链表的 `基地址`；而尾结点表示链表的最后一个结点，它的指针不是指向下一个结点，而是指向一个 `空地址 NULL`；
- 链表的插入、删除操作只需 O(1) 的时间复杂度（只需改变相邻结点的指针指向），而查询遍历需要 O(n) 的时间复杂度。


### 循环链表

![](https://github.com/bigrotor187/awesome-java-notes/blob/master/imgs/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.jpg)


- 循环链表是一种特殊的单链表，区别在于 `循环链表`  的尾结点指针指向的是链表的头结点，而不是指向空地址；
- 适用于处理具有 `环形结构`  特点的数据，比如著名的 `约瑟夫问题`。


### 双向链表

![](https://github.com/bigrotor187/awesome-java-notes/blob/master/imgs/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.jpg)

- 双向链表的每个结点除了存储数据，还有两个指针，分别是 `前驱指针 prev`  和 `后继指针 next` ；
- 首结点的前驱指针和尾结点的后继指针均指向 `空地址 NULL`；
- 性能情况：
    - 双向链表支持 O(1) 时间复杂度的情况下找到前驱结点；
    - `插入、删除` 操作效率高于单链表，只需要 O(1) 时间复杂度；
    - 以 `删除` 操作为例，有以下两种情况。对于第 1 种情况，单向链表和双向链表都需要从头到尾遍历链表，找到值等于给定值的结点再删除，需要 ` O(n)`  时间复杂度；对于第 2 种情况，已经找到要删除的结点，但删除某个结点 q 需要知道其前驱结点，单链表需要从头遍历找到前驱结点，当 p -> next = q，说明 p 是 q 的前驱结点,，需要 `O(n)` 时间复杂度。而双向链表因为已经保存了前驱结点的指针，可以直接获取到前驱结点，只需要 O(1) 时间复杂度。
        - 1、删除结点中“值等于某个给定值”的结点；
        - 2、删除给定指针指向的结点。
    - 对于一个 `有序链表` ，双向链表的 `按值查询`  的效率高于单链表。因为双向链表可以记录上一次查找的位置 p，每次查询时可以根据要查找的值与 p 的大小关系决定向前还是向后查找，平均只需要查找 `一半` 的数据。


### 双向循环链表

![](https://github.com/bigrotor187/awesome-java-notes/blob/master/imgs/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.jpg)


- 首结点的前驱指针指向尾节点，尾节点的后继指针指向首结点。


## 数组 VS 链表


> 对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗

![](https://github.com/bigrotor187/awesome-java-notes/blob/master/imgs/%E6%95%B0%E7%BB%84_%E9%93%BE%E8%A1%A8%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94.jpg)

- 插入、删除和随机访问的时间复杂度
    - 数组：插入、删除的时间复杂度为 O(n)，随机访问的时间复杂度为 O(1)；
    - 链表：插入、删除的时间复杂度为 O(1)，随机访问的时间复杂度为 O(n)。

- 数组和链表的缺点
    - 数组
        - 大小固定，一经声明就需要占用整块连续的内存空间；
        - 如果声明的数组过大，系统没有足够的连续内存空间可分配，就会导致“内存不足”；
        - 如果声明的数组过小，则可能出现不够用的情况，需要申请一个更大的内存，将原数组拷贝进去，非常耗时。

    - 链表
        - 链表中的每个结点都需要消耗额外的存储空间去存储指针信息；
        - 对链表进行频繁的插入、删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，可能会导致频繁的 GC（垃圾回收）。


## 如何轻松写出正确的链表代码？

### 技巧一：理解指针或引用的含义

> **将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。**

比如，`p->next=q`，意思就是 p 结点中的 next 指针存储了 q 结点的内存地址。而 `p->next=p->next->next` 则表示 p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址。 


### 技巧二：警惕指针丢失和内存泄漏

![](https://github.com/bigrotor187/awesome-java-notes/blob/master/imgs/%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9.jpg)

1、插入结点：

- 在结点 a 和 b 之间插入结点 x，假设当前指针 p 指向结点 a。如果写成 `p->next = x; x->next = p->next;` 这显然会导致指针指向 x 自身，因为经过 `p->next = x;` 之后，p 结点不再指向 b，而是指向了 x。正确的做法应该是交换两句代码的顺序：`x->next = p->next; p->next = x;`。

2、删除结点：

- b 是 a 的下一个结点，假设当前结点 p 指向结点 a。现要删除结点 b，应写成：`p->next = p->next->next;`。

### 技巧三：利用哨兵简化实现难度

1、什么是哨兵？

哨兵是用来解决链表的“边界问题”的，不直接参与业务逻辑。

2、未引入哨兵的情况

如果要在结点 p 后插入一个新的结点，只需两行代码：`new_node->next = p->next; =->next = new_node;` 即可搞定，但是，如果是向一个空链表插入第一个结点，这种逻辑就不对，需要这么做：
```java
if (head == null) {
    head = new_node;
}
```
而对于单链表的删除操作，如果要删除结点 p 的后继结点，只需一行代码 `p->next = p->next->next;` 即可搞定。但如果是要删除链表中的最后一个结点，前面的删除逻辑就不对了，需要这么做：

```java
if (head->next == null) {
    head = null;
}
```
也就是说，**针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理**，这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错。

3、引入哨兵的情况

![](https://github.com/bigrotor187/awesome-java-notes/blob/master/imgs/%E5%B8%A6%E5%A4%B4%E9%93%BE%E8%A1%A8.jpg)

如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。而哨兵结点是不存储数据的，因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。

### 技巧四：重点留意边界条件处理

写完链表代码后，经常用来检查链表代码是否正确的边界条件有这样几个：

- 如果链表为空时，代码是否能正常工作？

- 如果链表只包含一个结点时，代码是否能正常工作？

- 如果链表只包含两个结点时，代码是否能正常工作？

- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

### 技巧五：举例画图，辅助思考

对于稍微复杂的链表操作，比如单链表的反转，指针一会儿指这，一会儿指那儿，很容易绕晕，经常感觉脑容量不够，所以最好找个具体的例子画在纸上，释放一些脑容量，留更多的给逻辑思考，让思路更清晰。


### 技巧六：多写多练，没有捷径

多写多练几遍常见的链表操作，熟能生巧：

- 单链表反转

- 链表中环的检测

- 两个有序的链表合并

- 删除链表倒数第 n 个结点

- 求链表的中间结点



## 解答思考题

>  - **1、如何实现LRU缓存淘汰算法？**

可以维护一个有序单链表，越靠近尾部的结点是越早之前访问的。当一个新数据被访问时，从链表头开始顺遍历链表。

- 1、如果此数据之前已经被缓存在链表中，则遍历得到这个数据对应的结点，并将其从原来位置中删除，然后再插入到链表的头部；
- 2、如果此数据没有在缓存链表中，可以分为两种情况：
    - 如果此时缓存未满，则将此结点直接插入链表的头部；
    - 如果此时缓存已满，则删除链表尾结点，将新的数据结点插入链表头部。

分析：因为不管缓存有没有满，都需要遍历一遍链表，所以访问缓存的时间复杂度为 O(n)。如果想要优化，可以引入 `散列表`  来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。

## 参考链接

> 《数据结构与算法之美》专栏 王争

说明：本文来源于王争老师专栏的学习总结。



